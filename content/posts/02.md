---
title: "Title TODO"
date: 2023-07-01T16:25:59+02:00
---

In the [last post](/posts/six-times-faster-than-c/), we wrote a tiny C program, compiled it, disassembled it,
then tweaked that assembly to make it six times faster.

Our first version was able to process 295.26MiB/s, and our best version
reached 1.94GiB/s.

-- TODO check link matches title

The code listings for this post can be found on [Github](https://github.com/414owen/blog-code/tree/master/02-twice-as-fast-as-asm).

So, let's start with the first C version:


{{< tabs groupId="initial" >}}

{{% tab name="C" %}}
```C
int run_switches(char *input) {
  int res = 0;
  while (true) {
    char c = *input++;
    switch (c) {
      case '\0':
        return res;
      case 's':
        res += 1;
        break;
      case 'p':
        res -= 1;
        break;
      default:
        break;
    }
  }
}
```
{{% /tab %}}

{{% tab name="asm + pseudocode" %}}
```asm
# llvm-objdump -d  --symbolize-operands --no-addresses --x86-asm-syntax=intel --no-show-raw-insn

run_switches:
      xor     eax, eax            # res = 0
loop:                             # while (true) {
      movsx   ecx, byte ptr [rdi] #   c = *input
      test    ecx, ecx            #   if (c == '\0')
      je      ret                 #     return
      add     rdi, 1              #   input++
      cmp     ecx, 'p'            #   if (c == 'p')
      je      p                   #     goto p
      cmp     ecx, 's'            #   if (c == 's')
      jne     loop                #     continue
      add     eax, 1              #   res++
      jmp     loop                #   continue
p:    add     eax, -1             #   res--
      jmp     loop                # }
ret:  ret
```
{{% /tab %}}

{{% tab name="asm + arrows" %}}
```asm
# objdump -Mintel -d --no-addresses --no-show-raw-insn --visualize-jumps just-switch-gcc.c.o

run_switches:
              xor    eax, eax
loop:
      ╭────➤ movsx  ecx, byte ptr [rdi]
      │      test   ecx, ecx
      │ ╭─── je     ret
      │ │    add    rdi, 1
      │ │    cmp    ecx, 'p'
      │ │ ╭─ je     p
      │ │ │  cmp    ecx, 's'
      ├─│─│─ jne    loop
      │ │ │  add    eax, 1
      ├─│─│─ jmp    loop
p:    │ │ ╰➤ add    eax, -1
      ╰─│─── jmp    loop
ret:    ╰──➤ ret
```
{{% /tab %}}
{{< /tabs >}}

**Runtime:** 3.23s 🐌

**Bitrate**: 295.26MiB/s

## Dropping cases

The way we've expressed this problem is the pretty logical top-down way.
We're looping over out input, one character at a time, and performing a
[case analysis](https://en.wikipedia.org/wiki/Proof_by_exhaustion) over
the possible variants (or switching over the characters, if you prefer).

Based on this case analysis, we run different code.

To avoid this, let's merge the codepaths with common structure.
Both the 'p' and 's' cases add a number to the accumulator, so what if,
instead of performing case analysis to get the next code path, we do so
to get the number to add.

We can look up the number to add in an array:


{{< tabs groupId="arr-lookup" >}}
{{% tab name="C" %}}
```C
#include <stdbool.h>

static
int to_add[256] = {
  ['s'] = 1,
  ['p'] = -1,
};

int run_switches(const char *input) {
  int res = 0;
  while (true) {
    char c = *input++;
    if (c == '\0') {
      return res;
    } else {
      res += to_add[(int) c];
    }
  }
}
```
{{% /tab %}}

{{% tab name="gcc asm" %}}
```asm
# objdump -Mintel -d --no-addresses --no-show-raw-insn --visualize-jumps loop-2-gcc.c.o

run_switches:
           movsx  rax, BYTE PTR [rdi]
           lea    rdx, [rdi+1]
           xor    ecx, ecx
           lea    rsi, [rip+0]        # <run_switches+0x11>
           test   al,  al
      ╭─── je     ret
      │    nop    DWORD PTR [rax]
loop: │ ╭➤ add    rdx, 0x1
      │ │  add    ecx, DWORD PTR [rsi+rax*4]
      │ │  movsx  rax, BYTE PTR [rdx-1]
      │ │  test   al,  al
      │ ╰─ jne    loop
ret:  ╰──➤ mov    eax, ecx
           ret
```
{{% /tab %}}

{{% tab name="clang asm" %}}
```asm
# objdump -Mintel -d --no-addresses --no-show-raw-insn --visualize-jumps loop-2-clang.c.o

run_switches:
           mov    cl,  BYTE PTR [rdi]
           test   cl,  cl
      ╭─── je     ret
      │    add    rdi, 0x1
      │    xor    eax, eax
      │    lea    rdx, [rip+0x0]        # <run_switches+0x13>
      │    cs nop WORD PTR [rax+rax*1+0x0]
      │    nop    DWORD PTR [rax]
loop: │ ╭➤ movsx  rcx, cl
      │ │  add    eax, DWORD PTR [rdx+rcx*4]
      │ │  movzx  ecx, BYTE PTR [rdi]
      │ │  add    rdi, 0x1
      │ │  test   cl,  cl
      │ ╰─ jne    loop
      │    ret
ret:  ╰──➤ xor    eax, eax
           ret
```
{{% /tab %}}
{{< /tabs >}}


**GCC Runtime:** 0.47s 🦓

**GCC Bitrate**: 1.98GiB/s

**Clang Runtime:** 0.25s 🐆

**Clang Bitrate**: 3.72GiB/s

Sweet, well this is just as fast as our best (cmov) version from the previous
post. Something really weird is going on with the difference between gcc and
llvm though.

How big can the performance difference between these lines really be?

```
movzx  ecx, BYTE PTR [rdi]
movsx  rax, BYTE PTR [rdx-1]
```

I think I can get gcc to generate a version with movzx (move and zero-extend)
instead of movsx (move and sign-extend). Let's give it a go:


{{< tabs groupId="arr-lookup-2" >}}
{{% tab name="C" %}}
```C
#include <stdbool.h>
#include <stdint.h>

static
int to_add[256] = {
  ['s'] = 1,
  ['p'] = -1,
};

int run_switches(const uint8_t *input) {
  int res = 0;
  while (true) {
    uint8_t c = *input++;
    if (c == '\0') {
      return res;
    } else {
      res += to_add[(int) c];
    }
  }
}
```
{{% /tab %}}

{{% tab name="gcc asm" %}}
```asm
# objdump -Mintel -d --no-addresses --no-show-raw-insn --visualize-jumps loop-3-gcc.c.o

run_switches:
               movzx  eax, BYTE PTR [rdi]
               lea    rdx, [rdi+0x1]
               xor    ecx, ecx
               lea    rsi, [rip+0x0]        # <run_switches+0x10>
               test   al,  al
        ╭───── je     ret
        │      nop    DWORD PTR [rax+0x0]
        │  ╭─➤ movzx  eax, al
        │  │   add    rdx, 1
        │  │   add    ecx, DWORD PTR [rsi+rax*4]
        │  │   movzx  eax, BYTE PTR [rdx-1]
        │  │   test   al,  al
        │  ╰── jne    loop
        ╰────➤ mov    eax,ecx
               ret
```
{{% /tab %}}

{{% tab name="clang asm" %}}
```asm
# objdump -Mintel -d --no-addresses --no-show-raw-insn --visualize-jumps loop-2-clang.c.o

run_switches:
               mov    cl,  BYTE PTR [rdi]
               test   cl,  cl
        ╭───── je     ret
        │      add    rdi, 1
        │      xor    eax, eax
        │      lea    rdx, [rip+0x0]        # <run_switches+0x13>
        │      cs nop WORD PTR [rax+rax*1+0x0]
        │      nop    DWORD PTR [rax]
loop:   │  ╭─➤ movzx  ecx, cl
        │  │   add    eax, DWORD PTR [rdx+rcx*4]
        │  │   movzx  ecx, BYTE PTR [rdi]
        │  │   add    rdi, 1
        │  │   test   cl,  cl
        │  ╰── jne    loop
        │      ret
ret:    ╰────➤ xor    eax,eax
               ret
```
{{% /tab %}}
{{< /tabs >}}





Let's rewrite this in assembly to find out what's going on.

